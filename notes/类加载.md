#类加载
    -XX:+TraceClassLoading
####java虚拟机将会因为以下原因结束生命周期  
    1.System.exit()
    2.正常结束
    3.异常终止，无catch情况
    4.系统错误导致（无法控制）

##类加载描述：
    类型加载，连接，初始化的过程是在**程序运行期间**完成的（比如动态代理）  
    是由类加载器将类文件加载到jvm  
    过程：  
    将.class的二进制文件读入到内存中，并将其（文件）放在方法区内，然后在内存中创建一个  
    java.lang.Class的对象（虚拟机规范没有规定必须放在何处，hotspot也放在方法区内）  
    该对象用来封装在方法区内的Class对象（被加载的.class）的数据结构
    ※重要：
    类不是必须“首次使用”就会加载，加载器预计某个类会被使用，那么就会加载该类  
    如果.class文件缺失，则在“主动使用”时报出连接错误，否则未使用到该类就不会报错
###加载：
    查找并将类的二进制文件.class文件加载到内存中
    ※注意：可以使用-XX:+TraceClassLoading 开启是否显示当前加载的类
    方式：  
    1.本地文件
    2.网络下载
    3.zip，jar
    4.class文件数据库
    5.动态代理 jdkproxy/cglib
    
###连接：
    1. 验证：  
        &nbsp;&nbsp;确保被加载的类的正确性
    
    2. 准备：※重要  
        &nbsp;&nbsp;为类的**静态变量**分配内存，并将其初始化为默认值（例如int就为0）  
        &nbsp;&nbsp;例：static int a = 1;此过程后a = 0
        
    3. 解析：  
        &nbsp;&nbsp;把类中的符号引用转换为直接引用  
        &nbsp;&nbsp;把符号引用的地方直接转换成内存地址指向  
      
###初始化：※重要  
    为类的**静态变量**赋予正确的值，经过此步骤后 a = 1
####初始化的时机：
    java对类的使用有主动使用和被动使用2种，只有在主动使用的时候 才会初始化  

    主动使用：  
        1. 创建类的实例  
        2. 访问某个类/接口的静态变量，或对静态变量赋值  
        3. 调用静态方法  
        4. 反射 Class.forName("com.test.Aclass")  
        5. 初始化一个类的子类（初始化子类代表对父类的主动使用）  
            &nbsp;&nbsp;※注意：此规则不适用于接口，对于接口只有使用到接口内的变量，且该变量  
            &nbsp;&nbsp;&nbsp;&nbsp;无法直接放入到调用方法的主类的常量池中时，才会对该接口初始化  
        6. 标记为启动类的类，包含Main（）  
        7. 动态语言xxstatic  
    
    被动使用：  
        不会初始化  
    

###使用：
    类实例化：  
    1. 为新的对象分配内存
    2. 为实例的变量赋默认值
    3. 为实例的变量赋正确值
    4. java编译器为它编译的每一个类都至少生成一个构造方法（在class中该方法为<init>）

###卸载
    -XX:+TraceClassLoading
    *. 一个类何时结束生命周期取决于代表它的Class对象何时结束生命周期，也就是当加载成都Class对象不再被引用时
    1. 在jvm生命周期中，由java自带的加载器加载的类永远不会被卸载
    2. 由用户自定义的加载器加载的类可以被卸载

##类加载器：
+ java自带：
    + bootstrap（根类加载器）
    + extension（扩展类加载器）
    + system（应用/系统类加载器）  

+ 用户自定义
    + java.lang.ClassLoader的子类，且可自定义加载方式
    
###双亲委托机制：
    顶:  Bootstrap ClassLoader  ---> rt.jar/xbootclasspath选项指定的jar
         Extension ClassLoader  ---> ext/文件夹下的jar
         App ClassLoader        ---> load CLASSPATH或者-Djava.class.path所指定目录下的类和jar
    底:  Customer ClassLoader   ---> 通过java.lang.ClassLoader的子类自定义加载的class
    1. 自底向上检查类是否已经加载
    2. 自顶向下尝试类的加载
    
###类加载器命名空间
1. 每个**类加载器实例**都有自己的命名空间**命名空间由该加载器及所有父加载器所加载的类组成**
2. 在同一个命名空间中，不会出现类的完整名字（包括类的包名的名称）相同的两个类
3. 在不同命名空间中，有可能出现类的完整名字（包括类的包名的名称）相同的两个类  
  
+ 子加载器所加载的类**可以访问**到父加载器加载的类  
+ 父加载器所加载的类**无法访问**到子加载器加载的类